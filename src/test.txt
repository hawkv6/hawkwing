
// static int parse_dns_query(struct xdp_md *ctx, void* dns_query_start, struct dns_query *query) {
//     void *data_end = (void *)(long)ctx->data_end;
//     __u16 i;
//     void *cursor = dns_query_start;
//     int namepos = 0;

//     // Filling with zero for the verifier to be happy
//     // It could be an indirect read from the stack otherwise
//     for (int i = 0; i < sizeof(query->name); i++) {
//         query->name[i] = 0;
//     }
//     // memset(&query->name[0], 0, sizeof(query->name));
//     query->record_type = 0;
//     query->record_class = 0;

//     for (i = 0; i < MAX_DNS_NAME_LENGTH; i++) {
//         //Boundary check of cursor. Verifier requires a +1 here. 
//         //Probably because we are advancing the pointer at the end of the loop
//         if (cursor + 1 > data_end) {
//             break;
//         }

//         //If separator is zero we've reached the end of the domain query
//         if (*(char *)(cursor) == 0) {

//             //We've reached the end of the query name.
//             //This will be followed by 2x 2 bytes: the dns type and dns class.
//             if (cursor + 5 > data_end) {
//                 bpf_printk("Error: boundary exceeded while retrieving DNS record type and class");
//             } else {
//                 query->record_type = bpf_htons(*(__u16 *)(cursor + 1));
//                 query->record_class = bpf_htons(*(__u16 *)(cursor + 3));
//             }

//             //Return the bytecount of (namepos + current '0' byte + dns type + dns class) as the query length.
//             return namepos + 1 + 2 + 2;
//         }

//         //Read and fill data into struct
//         query->name[namepos] = *(char *)(cursor);
//         namepos++;
//         cursor++;
//     }

//     return -1;
// }

// static int parse_dns_query(struct xdp_md *ctx, void *dns_query_start, struct dns_query *query) {
//     void *data_end = (void *)(long)ctx->data_end;
//     void *cursor = dns_query_start;
//     int namepos = 0;

//     // Initialize dns_query.name with zero bytes
//     for (int i = 0; i < MAX_DNS_NAME_LENGTH; i++) {
//         query->name[i] = 0;
//     }
//     query -> record_type = 0;
//     query -> record_class = 0;

//     // Loop to get each label of the DNS name
//     for (int i = 0; i < MAX_DNS_NAME_LENGTH; i++) {
//         if (cursor + 1 > data_end) {
//             return -1; // Exit if we're about to read past the end of the packet
//         }
        
//         __u8 label_len = *(__u8 *)cursor;
//         cursor++; // Move cursor to the start of the label data
        
//         if (label_len == 0) {
//             // End of the DNS name
//             if (cursor + 4 <= data_end) { // Check for enough space for type and class
//                 query->record_type = *(__u16 *)cursor;
//                 cursor += 2;
//                 query->record_class = *(__u16 *)cursor;
//             }
//             return namepos + 1 + 2 + 2; // Length of name + null byte + type + class
//         }

//         // Copy the label into q->name
//         for (int j = 0; j < label_len; j++) {
//             if (cursor + 1 > data_end || namepos >= MAX_DNS_NAME_LENGTH) {
//                 return -1; // Exit if we're about to read past the end of the packet or buffer
//             }
//             query->name[namepos] = *(__u8 *)cursor;
//             namepos++;
//             cursor++;
//         }

//         // Add a dot between labels (but not at the end)
//         if (namepos < MAX_DNS_NAME_LENGTH) {
//             query->name[namepos] = '.';
//             namepos++;
//         }
//     }

//     return -1; // Return -1 if we've reached here (we shouldn't, if the packet is well-formed)
// }


static inline int check_bounds(void *cursor, void *data_end, int len) {
    return cursor + len <= data_end;
}

static inline void copy_label(char *dest, __u8 *src, int label_len, int *namepos) {
    for (int i = 0; i < label_len; i++) {
        dest[*namepos] = src[i];
        (*namepos)++;
    }
}

static int parse_dns_query(struct xdp_md *ctx, void *dns_query_start, struct dns_query *query) {
    void *data_end = (void *)(long)ctx->data_end;
    __u8 *cursor = dns_query_start;
    int namepos = 0;

    for (int i = 0; i < MAX_DNS_NAME_LENGTH; i++){
        query->name[i] = 0;
    }
    query->record_type = 0;
    query->record_class = 0;

    for (int i = 0; i < MAX_DNS_NAME_LENGTH; i++) {
        if (!check_bounds(cursor, data_end, 1)) return -1;

        __u8 label_len = *cursor++;
        
        if (label_len == 0) {
            if (check_bounds(cursor, data_end, 4)) {
                query->record_type = *(__u16 *)cursor;
                cursor += 2;
                query->record_class = *(__u16 *)cursor;
            }
            return namepos + 1 + 2 + 2;
        }

        if (!check_bounds(cursor, data_end, label_len) || namepos >= MAX_DNS_NAME_LENGTH - 1) {
            return -1;
        }

        copy_label(query->name, cursor, label_len, &namepos);
        cursor += label_len;

        if (namepos < MAX_DNS_NAME_LENGTH - 1) {
            query->name[namepos++] = '.';
        }
    }

    return -1;
}